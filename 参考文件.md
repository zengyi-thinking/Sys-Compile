下面我 **按编译器的经典六个阶段** ，**一步一步**用你给的 C 风格代码来详细讲解。为了便于理解，我会给出 **示例结果** ，而不是只讲抽象概念。

---

## 一、源代码（输入）

```c
// 数组测试
int main() {
    int arr[5];
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    int sum = arr[0] + arr[1] + arr[2];
    return sum;
}
```

---

# 1️⃣ 词法分析（Lexical Analysis）

### 🎯 目标

* 把**字符流** → **Token（记号）流**
* 去掉注释、空白
* 识别关键字、标识符、常量、运算符、分隔符

---

### 示例：词法分析结果（Token 序列）

| Token 类型 | 内容       |
| ---------- | ---------- |
| KEYWORD    | `int`    |
| IDENTIFIER | `main`   |
| SYMBOL     | `(`      |
| SYMBOL     | `)`      |
| SYMBOL     | `{`      |
| KEYWORD    | `int`    |
| IDENTIFIER | `arr`    |
| SYMBOL     | `[`      |
| NUMBER     | `5`      |
| SYMBOL     | `]`      |
| SYMBOL     | `;`      |
| IDENTIFIER | `arr`    |
| SYMBOL     | `[`      |
| NUMBER     | `0`      |
| SYMBOL     | `]`      |
| OPERATOR   | `=`      |
| NUMBER     | `1`      |
| SYMBOL     | `;`      |
| ...        | ...        |
| KEYWORD    | `return` |
| IDENTIFIER | `sum`    |
| SYMBOL     | `;`      |
| SYMBOL     | `}`      |

📌 **注释 `// 数组测试` 在此阶段被丢弃**

---

# 2️⃣ 语法分析（Syntax Analysis）

### 🎯 目标

* 根据**语法规则**检查结构是否正确
* 构建 **抽象语法树（AST）**

---

### 示例：抽象语法树（AST，简化）

```
FunctionDecl: main
 ├── ReturnType: int
 ├── Body
 │    ├── VarDecl: arr[5]
 │    ├── Assign
 │    │     ├── ArrayAccess: arr[0]
 │    │     └── Constant: 1
 │    ├── Assign
 │    │     ├── ArrayAccess: arr[1]
 │    │     └── Constant: 2
 │    ├── Assign
 │    │     ├── ArrayAccess: arr[2]
 │    │     └── Constant: 3
 │    ├── VarDecl: sum
 │    │     └── BinaryExpr (+)
 │    │          ├── ArrayAccess arr[0]
 │    │          ├── ArrayAccess arr[1]
 │    │          └── ArrayAccess arr[2]
 │    └── Return sum
```

📌 如果写成 `int arr[5`（少 `]`），**这里就会报语法错误**

---

# 3️⃣ 语义分析（Semantic Analysis）

### 🎯 目标

* 检查**意义是否正确**
* 建立 **符号表**
* 类型检查、作用域检查、数组越界（编译期可检查部分）

---

### ① 符号表（Symbol Table）

| 名称 | 类型     | 作用域 | 额外信息 |
| ---- | -------- | ------ | -------- |
| main | function | global | 返回 int |
| arr  | int[5]   | main   | 基地址   |
| sum  | int      | main   | -        |

---

### ② 语义检查示例

✔ `arr` 已声明
✔ `arr[0]` 类型是 `int`
✔ `sum` 类型是 `int`
✔ `return sum` 类型匹配函数返回值

❌ 如果写：

```c
arr[5] = 10;
```

👉 **语义错误（越界，部分编译器能检测）**

---

# 4️⃣ 中间代码生成（Intermediate Code Generation）

### 🎯 目标

* 生成与平台无关的中间表示（IR）
* 常见形式：**三地址码（TAC）**

---

### 示例：三地址码（TAC）

```
arr[0] = 1
arr[1] = 2
arr[2] = 3

t1 = arr[0]
t2 = arr[1]
t3 = t1 + t2
t4 = arr[2]
t5 = t3 + t4
sum = t5

return sum
```

📌 `t1 ~ t5` 是**临时变量**

---

# 5️⃣ 代码优化（Optimization）

### 🎯 目标

* 提高执行效率
* 减少指令数、内存访问

---

### 🔧 常见优化（针对本例）

#### ① 常量传播 / 合并（若允许）

```
arr[0] = 1
arr[1] = 2
arr[2] = 3

sum = 1 + 2 + 3
return sum
```

#### ② 常量折叠

```
sum = 6
return 6
```

📌 在 **O2/O3** 优化级别，很多编译器会直接这么干

---

# 6️⃣ 目标代码生成（Target Code Generation）

### 🎯 目标

* 生成特定平台的汇编代码（如 x86、ARM）

---

### 示例：x86-64 汇编（简化）

```asm
mov DWORD PTR [rbp-20], 1   ; arr[0]
mov DWORD PTR [rbp-16], 2   ; arr[1]
mov DWORD PTR [rbp-12], 3   ; arr[2]

mov eax, 1
add eax, 2
add eax, 3

leave
ret
```

📌 如果优化更激进，甚至可能直接：

```asm
mov eax, 6
ret
```

---

## 🔚 编译流程总览（记忆版）

```
源代码
  ↓
词法分析（Token）
  ↓
语法分析（AST）
  ↓
语义分析（符号表 + 类型检查）
  ↓
中间代码（IR / 三地址码）
  ↓
代码优化
  ↓
目标代码（汇编 / 机器码）
```

---

## 📌 如果你愿意

我可以：

* 用 **LLVM IR** 真实展示
* 对比 **gcc -O0 / -O2** 的差别
* 手把手教你 **自己写一个简易编译器**
* 专门讲 **数组在内存中的地址计算**

只要你说一声 👍
